import dedent from 'dedent-js'
import Layout from '../components/Layout'
import Notice from '../components/Notice'
import TabbedCodeExamples from '../components/TabbedCodeExamples'

export default Layout
export const meta = {
  title: 'Responses',
  links: [
    { url: '#creating-responses', name: 'Creating responses' },
    { url: '#lazy-evaluation', name: 'Lazy evaluation' },
    { url: '#root-template-data', name: 'Root template data' },
    { url: '#maximum-response-size', name: 'Maximum response size' },
  ],
}

# Responses

## Creating responses

In your controller, provide both the name of the JavaScript page component, as well as any props (data) for the page.

In this example we're passing a single prop, called `event`, which contains four attributes (`id`, `title`, `start_date` and `description`) to the `Event/Show` page component.

<TabbedCodeExamples
  type="backend"
  snippets={[
    {
      framework: 'laravel',
      name: 'Laravel',
      language: 'php',
      code: dedent`
        use Inertia\\Inertia;\n
        class EventsController extends Controller
        {
            public function show(Event $event)
            {
                return Inertia::render('Event/Show', [
                    'event' => $event->only(
                        'id',
                        'title',
                        'start_date',
                        'description'
                    ),
                ]);
            }
        }
      `,
      description: `To make an Inertia response, use the Inertia render function. This method takes the component name, and allows you to pass props and view data.`,
    },
    {
      framework: 'rails',
      name: 'Rails',
      language: 'ruby',
      code: dedent`
        class EventsController < ApplicationController
          def show
            event = Event.find(params[:id])\n
            render inertia: 'Event/Show',
              props: {
                event: event.as_json(
                  only: [ :id, :title, :start_date, :description ]
                )
              }
          end
        end
      `,
      description: `To make an Inertia response, use the inertia renderer. This renderer takes the component name, and allows you to pass props and view_data as an options hash.`,
    },
  ]}
/>

<Notice>
  To ensure that pages load quickly, only return the minimum data required for the page. Also, be aware that all data
  returned from the controllers will be visible client-side, so be sure to omit sensitive information.
</Notice>

## Lazy evaluation

When using [partial reloads](/requests#partial-reloads) it's best to wrap the props (data) in a closure, so that it will only be evaluated if it's required.

<TabbedCodeExamples
  type="backend"
  snippets={[
    {
      framework: 'laravel',
      name: 'Laravel',
      language: 'php',
      code: dedent`
        class UsersController extends Controller
        {
            public function index()
            {
                return Inertia::render('Users/Index', [
                    // Lazily evaluated (only run if required)
                    'companies' => function () {
                        return Company::orderBy('name')
                            ->get('id', 'name');
                    },
                    // Evaluated immediately
                    'users' => User::orderBy('name')
                        ->select('id', 'name')
                        ->paginate(),
                ]);
            }
        }
      `,
    },
    {
      framework: 'rails',
      name: 'Rails',
      language: 'ruby',
      code: dedent`
        class UsersController < ApplicationController
          def index
            render inertia: 'Users/Index', props: {
              # Lazily evaluated (only run if required)
              companies: -> {
                Company.
                  order(:name).
                  as_json(only: [ :id, :name ])
              },
              
              # Evaluated immediately
              users: User.
                order(:name).
                paginate(params[:page]).
                as_json(only: [ :id, :name ])
            }
          end
        end
      `,
    },
  ]}
/>

## Root template data

There are situations where you may want to access your prop data in your root Blade template. For example, you may want to add a meta description tag, Twitter card meta tags, or Facebook Open Graph meta tags.

<TabbedCodeExamples
  type="backend"
  snippets={[
    {
      framework: 'laravel',
      name: 'Laravel',
      language: 'twig',
      code: dedent`
        <meta name="twitter:title" content="{{ $page['props']['event']->title }}">
      `,
      description: `These props are available via the $page variable.`,
    },
    {
      framework: 'rails',
      name: 'Rails',
      language: 'erb',
      code: dedent`
        <meta name="twitter:title" content="<%= page['props']['event'].title %>">
      `,
      description: `These props are available via the page variable.`,
    },
  ]}
/>

Sometimes you may even want to provide data that will not be sent to your JavaScript component.

<TabbedCodeExamples
  type="backend"
  snippets={[
    {
      framework: 'laravel',
      name: 'Laravel',
      language: 'php',
      code: dedent`
        return Inertia::render('Event', ['event' => $event])
            ->withViewData(['meta' => $event->meta]);
      `,
      description: `Do this using the withViewData() method.`,
    },
    {
      framework: 'rails',
      name: 'Rails',
      language: 'ruby',
      code: dedent`
        render inertia: 'Event', props: {event: event}, view_data: {meta: event.meta}
      `,
      description: `Do this using the "view_data" option`,
    },
  ]}
/>

You can then access this variable like a regular template variable.

<TabbedCodeExamples
  type="backend"
  snippets={[
    {
      framework: 'laravel',
      name: 'Laravel',
      language: 'twig',
      code: dedent`
        <meta name="description" content="{{ $meta }}">
      `,
    },
    {
      framework: 'rails',
      name: 'Rails',
      language: 'erb',
      code: dedent`
        <meta name="description" content="<%= meta %>">
      `,
    },
  ]}
/>

## Maximum response size

To enable client-side history navigation, all Inertia server responses are stored in the browser's history state. It's good to be aware that some browsers impose a size limit on how much data can be saved there. For example, [Firefox](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) has a size limit of 640k characters. This is generally much more than you'll ever need, but it's good to be aware of this when building an Inertia application.
